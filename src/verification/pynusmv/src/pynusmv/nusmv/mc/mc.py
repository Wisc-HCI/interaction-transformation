# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_mc')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_mc')
    _mc = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_mc', [dirname(__file__)])
        except ImportError:
            import _mc
            return _mc
        try:
            _mod = imp.load_module('_mc', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _mc = swig_import_helper()
    del swig_import_helper
else:
    import _mc
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

PRIuPTR = _mc.PRIuPTR
PRIdPTR = _mc.PRIdPTR
LLU = _mc.LLU
LLO = _mc.LLO
LLX = _mc.LLX
false = _mc.false
true = _mc.true
OUTCOME_GENERIC_ERROR = _mc.OUTCOME_GENERIC_ERROR
OUTCOME_PARSER_ERROR = _mc.OUTCOME_PARSER_ERROR
OUTCOME_SYNTAX_ERROR = _mc.OUTCOME_SYNTAX_ERROR
OUTCOME_FILE_ERROR = _mc.OUTCOME_FILE_ERROR
OUTCOME_SUCCESS_REQUIRED_HELP = _mc.OUTCOME_SUCCESS_REQUIRED_HELP
OUTCOME_SUCCESS = _mc.OUTCOME_SUCCESS

def Mc_Init() -> "void":
    """Mc_Init()"""
    return _mc.Mc_Init()

def Mc_End() -> "void":
    """Mc_End()"""
    return _mc.Mc_End()

def Mc_CheckCTLSpec(prop: 'Prop_ptr') -> "void":
    """Mc_CheckCTLSpec(Prop_ptr prop)"""
    return _mc.Mc_CheckCTLSpec(prop)

def Mc_CheckAGOnlySpec(prop: 'Prop_ptr') -> "void":
    """Mc_CheckAGOnlySpec(Prop_ptr prop)"""
    return _mc.Mc_CheckAGOnlySpec(prop)

def Mc_CheckInvar(prop: 'Prop_ptr') -> "void":
    """Mc_CheckInvar(Prop_ptr prop)"""
    return _mc.Mc_CheckInvar(prop)

def Mc_CheckInvarSilently(prop: 'Prop_ptr', trace: 'Trace_ptr *') -> "void":
    """Mc_CheckInvarSilently(Prop_ptr prop, Trace_ptr * trace)"""
    return _mc.Mc_CheckInvarSilently(prop, trace)

def Mc_CheckInvar_With_Strategy(prop: 'Prop_ptr', strategy: 'Check_Strategy', trace: 'Trace_ptr *', silent: 'boolean') -> "void":
    """Mc_CheckInvar_With_Strategy(Prop_ptr prop, Check_Strategy strategy, Trace_ptr * trace, boolean silent)"""
    return _mc.Mc_CheckInvar_With_Strategy(prop, strategy, trace, silent)

def Mc_CheckInvar_With_Strategy_And_Symbols(prop: 'Prop_ptr', strategy: 'Check_Strategy', trace: 'Trace_ptr *', silent: 'boolean', symbols: 'NodeList_ptr') -> "void":
    """Mc_CheckInvar_With_Strategy_And_Symbols(Prop_ptr prop, Check_Strategy strategy, Trace_ptr * trace, boolean silent, NodeList_ptr symbols)"""
    return _mc.Mc_CheckInvar_With_Strategy_And_Symbols(prop, strategy, trace, silent, symbols)

def Mc_CheckCompute(prop: 'Prop_ptr') -> "void":
    """Mc_CheckCompute(Prop_ptr prop)"""
    return _mc.Mc_CheckCompute(prop)

def Mc_check_psl_property(prop: 'Prop_ptr') -> "int":
    """Mc_check_psl_property(Prop_ptr prop) -> int"""
    return _mc.Mc_check_psl_property(prop)

def Mc_CheckLanguageEmptiness(fsm: 'BddFsm_ptr const', allinit: 'boolean', verbose: 'boolean') -> "void":
    """Mc_CheckLanguageEmptiness(BddFsm_ptr const fsm, boolean allinit, boolean verbose)"""
    return _mc.Mc_CheckLanguageEmptiness(fsm, allinit, verbose)

def Mc_rewrite_invar_get_sexp_fsm(prop: 'Prop_ptr const', layer: 'SymbLayer_ptr', created_var: 'node_ptr *') -> "SexpFsm_ptr":
    """Mc_rewrite_invar_get_sexp_fsm(Prop_ptr const prop, SymbLayer_ptr layer, node_ptr * created_var) -> SexpFsm_ptr"""
    return _mc.Mc_rewrite_invar_get_sexp_fsm(prop, layer, created_var)

def Mc_create_trace_from_bdd_state_input_list(bdd_enc: 'BddEnc_ptr const', symbols: 'NodeList_ptr const', desc: 'char const *', type: 'TraceType const', path: 'node_ptr') -> "Trace_ptr":
    """Mc_create_trace_from_bdd_state_input_list(BddEnc_ptr const bdd_enc, NodeList_ptr const symbols, char const * desc, TraceType const type, node_ptr path) -> Trace_ptr"""
    return _mc.Mc_create_trace_from_bdd_state_input_list(bdd_enc, symbols, desc, type, path)

def Mc_fill_trace_from_bdd_state_input_list(bdd_enc: 'BddEnc_ptr const', trace: 'Trace_ptr', path: 'node_ptr') -> "Trace_ptr":
    """Mc_fill_trace_from_bdd_state_input_list(BddEnc_ptr const bdd_enc, Trace_ptr trace, node_ptr path) -> Trace_ptr"""
    return _mc.Mc_fill_trace_from_bdd_state_input_list(bdd_enc, trace, path)

def Mc_trace_step_put_state_from_bdd(trace: 'Trace_ptr', step: 'TraceIter', bdd_enc: 'BddEnc_ptr', bdd: 'bdd_ptr') -> "void":
    """Mc_trace_step_put_state_from_bdd(Trace_ptr trace, TraceIter step, BddEnc_ptr bdd_enc, bdd_ptr bdd)"""
    return _mc.Mc_trace_step_put_state_from_bdd(trace, step, bdd_enc, bdd)

def Mc_trace_step_put_input_from_bdd(trace: 'Trace_ptr', step: 'TraceIter', bdd_enc: 'BddEnc_ptr', bdd: 'bdd_ptr') -> "void":
    """Mc_trace_step_put_input_from_bdd(Trace_ptr trace, TraceIter step, BddEnc_ptr bdd_enc, bdd_ptr bdd)"""
    return _mc.Mc_trace_step_put_input_from_bdd(trace, step, bdd_enc, bdd)

def print_spec(file: 'FILE *', prop: 'Prop_ptr') -> "void":
    """print_spec(FILE * file, Prop_ptr prop)"""
    return _mc.print_spec(file, prop)

def print_invar(file: 'FILE *', n: 'Prop_ptr') -> "void":
    """print_invar(FILE * file, Prop_ptr n)"""
    return _mc.print_invar(file, n)

def print_compute(arg1: 'FILE *', arg2: 'Prop_ptr') -> "void":
    """print_compute(FILE * arg1, Prop_ptr arg2)"""
    return _mc.print_compute(arg1, arg2)

def ex(arg1: 'BddFsm_ptr', arg2: 'BddStates') -> "BddStates":
    """ex(BddFsm_ptr arg1, BddStates arg2) -> BddStates"""
    return _mc.ex(arg1, arg2)

def ef(arg1: 'BddFsm_ptr', arg2: 'BddStates') -> "BddStates":
    """ef(BddFsm_ptr arg1, BddStates arg2) -> BddStates"""
    return _mc.ef(arg1, arg2)

def eg(arg1: 'BddFsm_ptr', arg2: 'BddStates') -> "BddStates":
    """eg(BddFsm_ptr arg1, BddStates arg2) -> BddStates"""
    return _mc.eg(arg1, arg2)

def eu(arg1: 'BddFsm_ptr', arg2: 'BddStates', arg3: 'BddStates') -> "BddStates":
    """eu(BddFsm_ptr arg1, BddStates arg2, BddStates arg3) -> BddStates"""
    return _mc.eu(arg1, arg2, arg3)

def au(arg1: 'BddFsm_ptr', arg2: 'BddStates', arg3: 'BddStates') -> "BddStates":
    """au(BddFsm_ptr arg1, BddStates arg2, BddStates arg3) -> BddStates"""
    return _mc.au(arg1, arg2, arg3)

def ebu(arg1: 'BddFsm_ptr', arg2: 'BddStates', arg3: 'BddStates', arg4: 'int', arg5: 'int') -> "BddStates":
    """ebu(BddFsm_ptr arg1, BddStates arg2, BddStates arg3, int arg4, int arg5) -> BddStates"""
    return _mc.ebu(arg1, arg2, arg3, arg4, arg5)

def ebf(arg1: 'BddFsm_ptr', arg2: 'BddStates', arg3: 'int', arg4: 'int') -> "BddStates":
    """ebf(BddFsm_ptr arg1, BddStates arg2, int arg3, int arg4) -> BddStates"""
    return _mc.ebf(arg1, arg2, arg3, arg4)

def ebg(arg1: 'BddFsm_ptr', arg2: 'BddStates', arg3: 'int', arg4: 'int') -> "BddStates":
    """ebg(BddFsm_ptr arg1, BddStates arg2, int arg3, int arg4) -> BddStates"""
    return _mc.ebg(arg1, arg2, arg3, arg4)

def abu(arg1: 'BddFsm_ptr', arg2: 'BddStates', arg3: 'BddStates', arg4: 'int', arg5: 'int') -> "BddStates":
    """abu(BddFsm_ptr arg1, BddStates arg2, BddStates arg3, int arg4, int arg5) -> BddStates"""
    return _mc.abu(arg1, arg2, arg3, arg4, arg5)

def minu(arg1: 'BddFsm_ptr', arg2: 'bdd_ptr', arg3: 'bdd_ptr') -> "int":
    """minu(BddFsm_ptr arg1, bdd_ptr arg2, bdd_ptr arg3) -> int"""
    return _mc.minu(arg1, arg2, arg3)

def maxu(arg1: 'BddFsm_ptr', arg2: 'bdd_ptr', arg3: 'bdd_ptr') -> "int":
    """maxu(BddFsm_ptr arg1, bdd_ptr arg2, bdd_ptr arg3) -> int"""
    return _mc.maxu(arg1, arg2, arg3)

def explain(arg1: 'BddFsm_ptr', arg2: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'node_ptr', arg5: 'node_ptr') -> "node_ptr":
    """explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, node_ptr arg4, node_ptr arg5) -> node_ptr"""
    return _mc.explain(arg1, arg2, arg3, arg4, arg5)

def eval_ctl_spec(arg1: 'BddFsm_ptr', enc: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'node_ptr') -> "bdd_ptr":
    """eval_ctl_spec(BddFsm_ptr arg1, BddEnc_ptr enc, node_ptr arg3, node_ptr arg4) -> bdd_ptr"""
    return _mc.eval_ctl_spec(arg1, enc, arg3, arg4)

def eval_formula_list(arg1: 'BddFsm_ptr', enc: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'node_ptr') -> "node_ptr":
    """eval_formula_list(BddFsm_ptr arg1, BddEnc_ptr enc, node_ptr arg3, node_ptr arg4) -> node_ptr"""
    return _mc.eval_formula_list(arg1, enc, arg3, arg4)

def eval_compute(arg1: 'BddFsm_ptr', enc: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'node_ptr') -> "int":
    """eval_compute(BddFsm_ptr arg1, BddEnc_ptr enc, node_ptr arg3, node_ptr arg4) -> int"""
    return _mc.eval_compute(arg1, enc, arg3, arg4)

def free_formula_list(arg1: 'DdManager *', arg2: 'node_ptr') -> "void":
    """free_formula_list(DdManager * arg1, node_ptr arg2)"""
    return _mc.free_formula_list(arg1, arg2)

def ex_explain(arg1: 'BddFsm_ptr', arg2: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'bdd_ptr') -> "node_ptr":
    """ex_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4) -> node_ptr"""
    return _mc.ex_explain(arg1, arg2, arg3, arg4)

def eu_explain(arg1: 'BddFsm_ptr', arg2: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'bdd_ptr', arg5: 'bdd_ptr') -> "node_ptr":
    """eu_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4, bdd_ptr arg5) -> node_ptr"""
    return _mc.eu_explain(arg1, arg2, arg3, arg4, arg5)

def eu_si_explain(fsm: 'BddFsm_ptr', enc: 'BddEnc_ptr', path: 'node_ptr', f: 'bdd_ptr', g_si: 'bdd_ptr', hulk: 'bdd_ptr') -> "node_ptr":
    """eu_si_explain(BddFsm_ptr fsm, BddEnc_ptr enc, node_ptr path, bdd_ptr f, bdd_ptr g_si, bdd_ptr hulk) -> node_ptr"""
    return _mc.eu_si_explain(fsm, enc, path, f, g_si, hulk)

def ex_si(fsm: 'BddFsm_ptr', si: 'bdd_ptr') -> "BddStatesInputs":
    """ex_si(BddFsm_ptr fsm, bdd_ptr si) -> BddStatesInputs"""
    return _mc.ex_si(fsm, si)

def eu_si(fsm: 'BddFsm_ptr', f: 'bdd_ptr', g: 'bdd_ptr') -> "BddStatesInputs":
    """eu_si(BddFsm_ptr fsm, bdd_ptr f, bdd_ptr g) -> BddStatesInputs"""
    return _mc.eu_si(fsm, f, g)

def eg_si(fsm: 'BddFsm_ptr', g_si: 'bdd_ptr') -> "BddStatesInputs":
    """eg_si(BddFsm_ptr fsm, bdd_ptr g_si) -> BddStatesInputs"""
    return _mc.eg_si(fsm, g_si)

def ebu_explain(arg1: 'BddFsm_ptr', arg2: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'bdd_ptr', arg5: 'bdd_ptr', arg6: 'int', arg7: 'int') -> "node_ptr":
    """ebu_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4, bdd_ptr arg5, int arg6, int arg7) -> node_ptr"""
    return _mc.ebu_explain(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

def eg_explain(arg1: 'BddFsm_ptr', arg2: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'bdd_ptr') -> "node_ptr":
    """eg_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4) -> node_ptr"""
    return _mc.eg_explain(arg1, arg2, arg3, arg4)

def ebg_explain(arg1: 'BddFsm_ptr', arg2: 'BddEnc_ptr', arg3: 'node_ptr', arg4: 'bdd_ptr', arg5: 'int', arg6: 'int') -> "node_ptr":
    """ebg_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4, int arg5, int arg6) -> node_ptr"""
    return _mc.ebg_explain(arg1, arg2, arg3, arg4, arg5, arg6)
# This file is compatible with both classic and new-style classes.

cvar = _mc.cvar

