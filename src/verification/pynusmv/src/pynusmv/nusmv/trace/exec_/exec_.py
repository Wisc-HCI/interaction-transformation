# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_exec_')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_exec_')
    _exec_ = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_exec_', [dirname(__file__)])
        except ImportError:
            import _exec_
            return _exec_
        try:
            _mod = imp.load_module('_exec_', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _exec_ = swig_import_helper()
    del swig_import_helper
else:
    import _exec_
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

PRIuPTR = _exec_.PRIuPTR
PRIdPTR = _exec_.PRIdPTR
LLU = _exec_.LLU
LLO = _exec_.LLO
LLX = _exec_.LLX
false = _exec_.false
true = _exec_.true
OUTCOME_GENERIC_ERROR = _exec_.OUTCOME_GENERIC_ERROR
OUTCOME_PARSER_ERROR = _exec_.OUTCOME_PARSER_ERROR
OUTCOME_SYNTAX_ERROR = _exec_.OUTCOME_SYNTAX_ERROR
OUTCOME_FILE_ERROR = _exec_.OUTCOME_FILE_ERROR
OUTCOME_SUCCESS_REQUIRED_HELP = _exec_.OUTCOME_SUCCESS_REQUIRED_HELP
OUTCOME_SUCCESS = _exec_.OUTCOME_SUCCESS

def Object_destroy(arg1: 'Object_ptr', arg: 'void *') -> "void":
    """Object_destroy(Object_ptr arg1, void * arg)"""
    return _exec_.Object_destroy(arg1, arg)

def Object_copy(arg1: 'Object_ptr const') -> "Object_ptr":
    """Object_copy(Object_ptr const arg1) -> Object_ptr"""
    return _exec_.Object_copy(arg1)

def BaseTraceExecutor_get_verbosity(arg1: 'BaseTraceExecutor_ptr') -> "int":
    """BaseTraceExecutor_get_verbosity(BaseTraceExecutor_ptr arg1) -> int"""
    return _exec_.BaseTraceExecutor_get_verbosity(arg1)

def BaseTraceExecutor_set_verbosity(arg1: 'BaseTraceExecutor_ptr', verbosity: 'int') -> "void":
    """BaseTraceExecutor_set_verbosity(BaseTraceExecutor_ptr arg1, int verbosity)"""
    return _exec_.BaseTraceExecutor_set_verbosity(arg1, verbosity)

def BaseTraceExecutor_get_output_stream(arg1: 'BaseTraceExecutor_ptr') -> "FILE *":
    """BaseTraceExecutor_get_output_stream(BaseTraceExecutor_ptr arg1) -> FILE *"""
    return _exec_.BaseTraceExecutor_get_output_stream(arg1)

def BaseTraceExecutor_set_output_stream(arg1: 'BaseTraceExecutor_ptr', error_stream: 'FILE *') -> "void":
    """BaseTraceExecutor_set_output_stream(BaseTraceExecutor_ptr arg1, FILE * error_stream)"""
    return _exec_.BaseTraceExecutor_set_output_stream(arg1, error_stream)

def BaseTraceExecutor_get_error_stream(arg1: 'BaseTraceExecutor_ptr') -> "FILE *":
    """BaseTraceExecutor_get_error_stream(BaseTraceExecutor_ptr arg1) -> FILE *"""
    return _exec_.BaseTraceExecutor_get_error_stream(arg1)

def BaseTraceExecutor_set_error_stream(arg1: 'BaseTraceExecutor_ptr', error_stream: 'FILE *') -> "void":
    """BaseTraceExecutor_set_error_stream(BaseTraceExecutor_ptr arg1, FILE * error_stream)"""
    return _exec_.BaseTraceExecutor_set_error_stream(arg1, error_stream)

def BaseTraceExecutor_destroy(arg1: 'BaseTraceExecutor_ptr') -> "void":
    """BaseTraceExecutor_destroy(BaseTraceExecutor_ptr arg1)"""
    return _exec_.BaseTraceExecutor_destroy(arg1)

def BDDCompleteTraceExecutor_create(fsm: 'BddFsm_ptr const', enc: 'BddEnc_ptr const') -> "BDDCompleteTraceExecutor_ptr":
    """BDDCompleteTraceExecutor_create(BddFsm_ptr const fsm, BddEnc_ptr const enc) -> BDDCompleteTraceExecutor_ptr"""
    return _exec_.BDDCompleteTraceExecutor_create(fsm, enc)

def BDDPartialTraceExecutor_create(fsm: 'BddFsm_ptr const', enc: 'BddEnc_ptr const') -> "BDDPartialTraceExecutor_ptr":
    """BDDPartialTraceExecutor_create(BddFsm_ptr const fsm, BddEnc_ptr const enc) -> BDDPartialTraceExecutor_ptr"""
    return _exec_.BDDPartialTraceExecutor_create(fsm, enc)

def CompleteTraceExecutor_execute(arg1: 'CompleteTraceExecutor_ptr const', trace: 'Trace_ptr const', n_steps: 'int *') -> "boolean":
    """CompleteTraceExecutor_execute(CompleteTraceExecutor_ptr const arg1, Trace_ptr const trace, int * n_steps) -> boolean"""
    return _exec_.CompleteTraceExecutor_execute(arg1, trace, n_steps)

def PartialTraceExecutor_execute(arg1: 'PartialTraceExecutor_ptr const', trace: 'Trace_ptr const', language: 'NodeList_ptr const', n_steps: 'int *') -> "Trace_ptr":
    """PartialTraceExecutor_execute(PartialTraceExecutor_ptr const arg1, Trace_ptr const trace, NodeList_ptr const language, int * n_steps) -> Trace_ptr"""
    return _exec_.PartialTraceExecutor_execute(arg1, trace, language, n_steps)

def SATCompleteTraceExecutor_create(fsm: 'BeFsm_ptr const', enc: 'BeEnc_ptr const', bdd_enc: 'BddEnc_ptr const') -> "SATCompleteTraceExecutor_ptr":
    """SATCompleteTraceExecutor_create(BeFsm_ptr const fsm, BeEnc_ptr const enc, BddEnc_ptr const bdd_enc) -> SATCompleteTraceExecutor_ptr"""
    return _exec_.SATCompleteTraceExecutor_create(fsm, enc, bdd_enc)

def SATPartialTraceExecutor_create(fsm: 'BeFsm_ptr const', enc: 'BeEnc_ptr const', bdd_enc: 'BddEnc_ptr const', use_restart: 'boolean') -> "SATPartialTraceExecutor_ptr":
    """SATPartialTraceExecutor_create(BeFsm_ptr const fsm, BeEnc_ptr const enc, BddEnc_ptr const bdd_enc, boolean use_restart) -> SATPartialTraceExecutor_ptr"""
    return _exec_.SATPartialTraceExecutor_create(fsm, enc, bdd_enc, use_restart)
BDD_EXEC_ENGINE = _exec_.BDD_EXEC_ENGINE
SAT_EXEC_ENGINE = _exec_.SAT_EXEC_ENGINE
EXEC_NONE = _exec_.EXEC_NONE
EXEC_BDD = _exec_.EXEC_BDD
EXEC_SAT = _exec_.EXEC_SAT
EXEC_RESERVED = _exec_.EXEC_RESERVED

def bddPartialTraceExecutor2partialTraceExecutor(ptr: 'BDDPartialTraceExecutor_ptr') -> "PartialTraceExecutor_ptr":
    """bddPartialTraceExecutor2partialTraceExecutor(BDDPartialTraceExecutor_ptr ptr) -> PartialTraceExecutor_ptr"""
    return _exec_.bddPartialTraceExecutor2partialTraceExecutor(ptr)

def bddCompleteTraceExecutor2completeTraceExecutor(ptr: 'BDDCompleteTraceExecutor_ptr') -> "CompleteTraceExecutor_ptr":
    """bddCompleteTraceExecutor2completeTraceExecutor(BDDCompleteTraceExecutor_ptr ptr) -> CompleteTraceExecutor_ptr"""
    return _exec_.bddCompleteTraceExecutor2completeTraceExecutor(ptr)
# This file is compatible with both classic and new-style classes.


