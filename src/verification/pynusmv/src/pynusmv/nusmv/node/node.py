# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_node')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_node')
    _node = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_node', [dirname(__file__)])
        except ImportError:
            import _node
            return _node
        try:
            _mod = imp.load_module('_node', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _node = swig_import_helper()
    del swig_import_helper
else:
    import _node
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


def node2bdd(ptr: 'node') -> "bdd_ptr":
    """node2bdd(node ptr) -> bdd_ptr"""
    return _node.node2bdd(ptr)

def bdd2node(ptr: 'bdd_ptr') -> "node_ptr":
    """bdd2node(bdd_ptr ptr) -> node"""
    return _node.bdd2node(ptr)

def int2node(val: 'int') -> "node_ptr":
    """int2node(int val) -> node"""
    return _node.int2node(val)

def node2int(ptr: 'node') -> "int":
    """node2int(node ptr) -> int"""
    return _node.node2int(ptr)

def string2node(string: 'string_ptr') -> "node_ptr":
    """string2node(string_ptr string) -> node"""
    return _node.string2node(string)

def node2string(node: 'node') -> "string_ptr":
    """node2string(node node) -> string_ptr"""
    return _node.node2string(node)

def node2word(node: 'node') -> "WordNumber_ptr":
    """node2word(node node) -> WordNumber_ptr"""
    return _node.node2word(node)

def word2node(word: 'WordNumber_ptr') -> "node_ptr":
    """word2node(WordNumber_ptr word) -> node"""
    return _node.word2node(word)

def node_equal(left: 'node', right: 'node') -> "boolean":
    """node_equal(node left, node right) -> boolean"""
    return _node.node_equal(left, right)
PRIuPTR = _node.PRIuPTR
PRIdPTR = _node.PRIdPTR
LLU = _node.LLU
LLO = _node.LLO
LLX = _node.LLX
false = _node.false
true = _node.true
OUTCOME_GENERIC_ERROR = _node.OUTCOME_GENERIC_ERROR
OUTCOME_PARSER_ERROR = _node.OUTCOME_PARSER_ERROR
OUTCOME_SYNTAX_ERROR = _node.OUTCOME_SYNTAX_ERROR
OUTCOME_FILE_ERROR = _node.OUTCOME_FILE_ERROR
OUTCOME_SUCCESS_REQUIRED_HELP = _node.OUTCOME_SUCCESS_REQUIRED_HELP
OUTCOME_SUCCESS = _node.OUTCOME_SUCCESS

def MasterNodeWalker_create() -> "MasterNodeWalker_ptr":
    """MasterNodeWalker_create() -> MasterNodeWalker_ptr"""
    return _node.MasterNodeWalker_create()

def MasterNodeWalker_destroy(arg1: 'MasterNodeWalker_ptr') -> "void":
    """MasterNodeWalker_destroy(MasterNodeWalker_ptr arg1)"""
    return _node.MasterNodeWalker_destroy(arg1)

def MasterNodeWalker_register_walker(arg1: 'MasterNodeWalker_ptr', walker: 'NodeWalker_ptr') -> "boolean":
    """MasterNodeWalker_register_walker(MasterNodeWalker_ptr arg1, NodeWalker_ptr walker) -> boolean"""
    return _node.MasterNodeWalker_register_walker(arg1, walker)

def MasterNodeWalker_unregister_walker(arg1: 'MasterNodeWalker_ptr', name: 'char const *') -> "NodeWalker_ptr":
    """MasterNodeWalker_unregister_walker(MasterNodeWalker_ptr arg1, char const * name) -> NodeWalker_ptr"""
    return _node.MasterNodeWalker_unregister_walker(arg1, name)
class value_(_object):
    """Proxy of C value_ struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, value_, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, value_, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inttype"] = _node.value__inttype_set
    __swig_getmethods__["inttype"] = _node.value__inttype_get
    if _newclass:
        inttype = _swig_property(_node.value__inttype_get, _node.value__inttype_set)
    __swig_setmethods__["nodetype"] = _node.value__nodetype_set
    __swig_getmethods__["nodetype"] = _node.value__nodetype_get
    if _newclass:
        nodetype = _swig_property(_node.value__nodetype_get, _node.value__nodetype_set)
    __swig_setmethods__["strtype"] = _node.value__strtype_set
    __swig_getmethods__["strtype"] = _node.value__strtype_get
    if _newclass:
        strtype = _swig_property(_node.value__strtype_get, _node.value__strtype_set)
    __swig_setmethods__["bddtype"] = _node.value__bddtype_set
    __swig_getmethods__["bddtype"] = _node.value__bddtype_get
    if _newclass:
        bddtype = _swig_property(_node.value__bddtype_get, _node.value__bddtype_set)

    def __init__(self):
        """__init__(value_ self) -> value_"""
        this = _node.new_value_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _node.delete_value_
    __del__ = lambda self: None
value__swigregister = _node.value__swigregister
value__swigregister(value_)

class node(_object):
    """Proxy of C node struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, node, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, node, name)
    __repr__ = _swig_repr
    __swig_setmethods__["link"] = _node.node_link_set
    __swig_getmethods__["link"] = _node.node_link_get
    if _newclass:
        link = _swig_property(_node.node_link_get, _node.node_link_set)
    __swig_setmethods__["type"] = _node.node_type_set
    __swig_getmethods__["type"] = _node.node_type_get
    if _newclass:
        type = _swig_property(_node.node_type_get, _node.node_type_set)
    __swig_setmethods__["lineno"] = _node.node_lineno_set
    __swig_getmethods__["lineno"] = _node.node_lineno_get
    if _newclass:
        lineno = _swig_property(_node.node_lineno_get, _node.node_lineno_set)
    __swig_setmethods__["left"] = _node.node_left_set
    __swig_getmethods__["left"] = _node.node_left_get
    if _newclass:
        left = _swig_property(_node.node_left_get, _node.node_left_set)
    __swig_setmethods__["right"] = _node.node_right_set
    __swig_getmethods__["right"] = _node.node_right_get
    if _newclass:
        right = _swig_property(_node.node_right_get, _node.node_right_set)
    __swig_setmethods__["extra_data"] = _node.node_extra_data_set
    __swig_getmethods__["extra_data"] = _node.node_extra_data_get
    if _newclass:
        extra_data = _swig_property(_node.node_extra_data_get, _node.node_extra_data_set)

    def __init__(self):
        """__init__(node self) -> node"""
        this = _node.new_node()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _node.delete_node
    __del__ = lambda self: None
node_swigregister = _node.node_swigregister
node_swigregister(node)


def node_pkg_init() -> "void":
    """node_pkg_init()"""
    return _node.node_pkg_init()

def node_pkg_quit() -> "void":
    """node_pkg_quit()"""
    return _node.node_pkg_quit()

def free_node(arg1: 'node') -> "void":
    """free_node(node arg1)"""
    return _node.free_node(arg1)

def swap_nodes(arg1: 'node_ptr *', arg2: 'node_ptr *') -> "void":
    """swap_nodes(node_ptr * arg1, node_ptr * arg2)"""
    return _node.swap_nodes(arg1, arg2)

def node_is_failure(node: 'node') -> "int":
    """node_is_failure(node node) -> int"""
    return _node.node_is_failure(node)

def node_is_leaf(node: 'node') -> "int":
    """node_is_leaf(node node) -> int"""
    return _node.node_is_leaf(node)

def walk(fun: 'VPFN', arg2: 'node') -> "void":
    """walk(VPFN fun, node arg2)"""
    return _node.walk(fun, arg2)

def create_node(arg1: 'int', arg2: 'node', arg3: 'node') -> "node_ptr":
    """create_node(int arg1, node arg2, node arg3) -> node"""
    return _node.create_node(arg1, arg2, arg3)

def new_lined_node(arg1: 'int', arg2: 'node', arg3: 'node', arg4: 'int') -> "node_ptr":
    """new_lined_node(int arg1, node arg2, node arg3, int arg4) -> node"""
    return _node.new_lined_node(arg1, arg2, arg3, arg4)

def cons(arg1: 'node', arg2: 'node') -> "node_ptr":
    """cons(node arg1, node arg2) -> node"""
    return _node.cons(arg1, arg2)

def car(arg1: 'node') -> "node_ptr":
    """car(node arg1) -> node"""
    return _node.car(arg1)

def cdr(arg1: 'node') -> "node_ptr":
    """cdr(node arg1) -> node"""
    return _node.cdr(arg1)

def new_list() -> "node_ptr":
    """new_list() -> node"""
    return _node.new_list()

def copy_list(l: 'node') -> "node_ptr":
    """copy_list(node l) -> node"""
    return _node.copy_list(l)

def free_list(l: 'node') -> "void":
    """free_list(node l)"""
    return _node.free_list(l)

def is_list_empty(arg1: 'node') -> "int":
    """is_list_empty(node arg1) -> int"""
    return _node.is_list_empty(arg1)

def in_list(arg1: 'node', arg2: 'node') -> "int":
    """in_list(node arg1, node arg2) -> int"""
    return _node.in_list(arg1, arg2)

def llength(arg1: 'node') -> "int":
    """llength(node arg1) -> int"""
    return _node.llength(arg1)

def append(arg1: 'node', arg2: 'node') -> "node_ptr":
    """append(node arg1, node arg2) -> node"""
    return _node.append(arg1, arg2)

def append_ns(arg1: 'node', arg2: 'node') -> "node_ptr":
    """append_ns(node arg1, node arg2) -> node"""
    return _node.append_ns(arg1, arg2)

def reverse(arg1: 'node') -> "node_ptr":
    """reverse(node arg1) -> node"""
    return _node.reverse(arg1)

def reverse_ns(arg1: 'node') -> "node_ptr":
    """reverse_ns(node arg1) -> node"""
    return _node.reverse_ns(arg1)

def last(arg1: 'node') -> "node_ptr":
    """last(node arg1) -> node"""
    return _node.last(arg1)

def map(fun: 'NPFN', arg2: 'node') -> "node_ptr":
    """map(NPFN fun, node arg2) -> node"""
    return _node.map(fun, arg2)

def map2(fun: 'NPFNN', arg2: 'node', arg3: 'node') -> "node_ptr":
    """map2(NPFNN fun, node arg2, node arg3) -> node"""
    return _node.map2(fun, arg2, arg3)

def even_elements(arg1: 'node') -> "node_ptr":
    """even_elements(node arg1) -> node"""
    return _node.even_elements(arg1)

def odd_elements(arg1: 'node') -> "node_ptr":
    """odd_elements(node arg1) -> node"""
    return _node.odd_elements(arg1)

def node_subtract(arg1: 'node', arg2: 'node') -> "node_ptr":
    """node_subtract(node arg1, node arg2) -> node"""
    return _node.node_subtract(arg1, arg2)

def find_node(arg1: 'int', arg2: 'node', arg3: 'node') -> "node_ptr":
    """find_node(int arg1, node arg2, node arg3) -> node"""
    return _node.find_node(arg1, arg2, arg3)

def find_atom(arg1: 'node') -> "node_ptr":
    """find_atom(node arg1) -> node"""
    return _node.find_atom(arg1)

def print_sexp(arg1: 'FILE *', arg2: 'node') -> "int":
    """print_sexp(FILE * arg1, node arg2) -> int"""
    return _node.print_sexp(arg1, arg2)

def print_array_type(output_stream: 'FILE *', body: 'node') -> "void":
    """print_array_type(FILE * output_stream, node body)"""
    return _node.print_array_type(output_stream, body)

def print_node(arg1: 'FILE *', arg2: 'node') -> "int":
    """print_node(FILE * arg1, node arg2) -> int"""
    return _node.print_node(arg1, arg2)

def sprint_node(arg1: 'node') -> "char *":
    """sprint_node(node arg1) -> char *"""
    return _node.sprint_node(arg1)

def print_node_indent_at(stream: 'FILE *', n: 'node', ofs: 'int') -> "int":
    """print_node_indent_at(FILE * stream, node n, int ofs) -> int"""
    return _node.print_node_indent_at(stream, n, ofs)

def sprint_node_indent_at(n: 'node', ofs: 'int') -> "char *":
    """sprint_node_indent_at(node n, int ofs) -> char *"""
    return _node.sprint_node_indent_at(n, ofs)

def print_node_indent(stream: 'FILE *', n: 'node') -> "int":
    """print_node_indent(FILE * stream, node n) -> int"""
    return _node.print_node_indent(stream, n)

def sprint_node_indent(n: 'node') -> "char *":
    """sprint_node_indent(node n) -> char *"""
    return _node.sprint_node_indent(n)

def setcar(arg1: 'node', arg2: 'node') -> "void":
    """setcar(node arg1, node arg2)"""
    return _node.setcar(arg1, arg2)

def setcdr(arg1: 'node', arg2: 'node') -> "void":
    """setcdr(node arg1, node arg2)"""
    return _node.setcdr(arg1, arg2)

def node_set_type(arg1: 'node', arg2: 'int') -> "void":
    """node_set_type(node arg1, int arg2)"""
    return _node.node_set_type(arg1, arg2)

def node_normalize(arg1: 'node') -> "node_ptr":
    """node_normalize(node arg1) -> node"""
    return _node.node_normalize(arg1)

def node_normalize_list(sexp: 'node') -> "node_ptr":
    """node_normalize_list(node sexp) -> node"""
    return _node.node_normalize_list(sexp)

def node_pkg_get_global_master_normalizer() -> "struct MasterNormalizer_TAG *":
    """node_pkg_get_global_master_normalizer() -> struct MasterNormalizer_TAG *"""
    return _node.node_pkg_get_global_master_normalizer()

def node_pkg_get_global_master_wff_printer() -> "struct MasterPrinter_TAG *":
    """node_pkg_get_global_master_wff_printer() -> struct MasterPrinter_TAG *"""
    return _node.node_pkg_get_global_master_wff_printer()

def node_pkg_get_global_master_sexp_printer() -> "struct MasterPrinter_TAG *":
    """node_pkg_get_global_master_sexp_printer() -> struct MasterPrinter_TAG *"""
    return _node.node_pkg_get_global_master_sexp_printer()

def node_pkg_get_indenting_master_wff_printer() -> "struct MasterPrinter_TAG *":
    """node_pkg_get_indenting_master_wff_printer() -> struct MasterPrinter_TAG *"""
    return _node.node_pkg_get_indenting_master_wff_printer()

def NodeWalker_destroy(arg1: 'NodeWalker_ptr') -> "void":
    """NodeWalker_destroy(NodeWalker_ptr arg1)"""
    return _node.NodeWalker_destroy(arg1)

def NodeWalker_can_handle(arg1: 'NodeWalker_ptr const', n: 'node') -> "boolean":
    """NodeWalker_can_handle(NodeWalker_ptr const arg1, node n) -> boolean"""
    return _node.NodeWalker_can_handle(arg1, n)

def NodeWalker_get_name(arg1: 'NodeWalker_ptr const') -> "char const *":
    """NodeWalker_get_name(NodeWalker_ptr const arg1) -> char const *"""
    return _node.NodeWalker_get_name(arg1)

def NodeWalker_collides(arg1: 'NodeWalker_ptr const', other: 'NodeWalker_ptr const') -> "boolean":
    """NodeWalker_collides(NodeWalker_ptr const arg1, NodeWalker_ptr const other) -> boolean"""
    return _node.NodeWalker_collides(arg1, other)
# This file is compatible with both classic and new-style classes.


