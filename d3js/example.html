<!DOCTYPE html>
<meta charset="utf-8">
<style>

.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

#licensing {
  fill: green;
}

.link.licensing {
  stroke: green;
}

.link.resolved {
  stroke-dasharray: 0,2 1;
}

circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

// http://blog.thomsonreuters.com/index.php/mobile-patent-suits-graphic-of-the-day/
var links = [];

var width = 400,
    height = 400;

d3.json("dimensions.json", function(data) {
  d3.json("links.json", function(state_machine_data) {
    var link_data = state_machine_data["links"]
    var state_data = state_machine_data["states"]
    console.log(state_data)
    console.log(data);

    var max_id = -1;
    for(var i = 0; i < link_data.length; i++) {
      var obj = link_data[i];

      var src = obj["source"]
      var src_name = obj["source_name"]
      var tar = obj["target"]
      var tar_name = obj["target_name"]
      var input = obj["input"]

      if (tar > max_id)
        max_id = tar
      if (src > max_id)
        max_id = src

      var is_alone = true;
      for (i in links) {
        //console.log("link " + src + " " + tar)
        //console.log("link " + links[i])
        if (src == links[i].target && tar == links[i].source) {
          is_alone = false;
          links[i].is_alone="false"
        }
      }

      if (is_alone)
        var temp_link = {source: src, sourcename: src_name, target: tar, targetname: tar_name, label: input, type:"suit", is_alone:"true"}
      else
        var temp_link = {source: src, sourcename: src_name, target: tar, targetname: tar_name, label: input, type:"suit", is_alone:"false"}
      if (temp_link.source == temp_link.target)
        temp_link.type="self_loop"

      console.log("THIS IS THE DAWNING")
      console.log(temp_link.source)
      console.log(state_data[temp_link.source])
      console.log(state_data[temp_link.source]["reachable"])
      if (state_data[temp_link.source]["reachable"] == false)
        temp_link.type = temp_link.type.concat("_gray")

      links.push(temp_link)
    }

    var nodes = {};

    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
      link.source = nodes[link.source] || (nodes[link.source] = {name: link.sourcename, real_id: link.source, gesture: state_data[link.source]["gesture"], final: state_data[link.source]["final"], reach: state_data[link.source]["reachable"]});
      link.target = nodes[link.target] || (nodes[link.target] = {name: link.targetname, real_id: link.target, gesture: state_data[link.target]["gesture"], final: state_data[link.target]["final"], reach: state_data[link.target]["reachable"]});
    });

    console.log(nodes)

    var width = data["width"];
    var height = data["height"];
    var nonverb = data["behaviors"]
  
    var force = d3.layout.force()
      .nodes(d3.values(nodes))
      .links(links)
      .size([width, height])
      .linkDistance(225)
      .charge(-10000)
      .on("tick", tick)
      .start();

    var node_drag = d3.behavior.drag()
      .on("dragstart", dragstart)
      .on("drag", dragmove)
      .on("dragend", dragend);
    
    var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

    // Per-type markers, as they don't inherit styles.
    svg.append("defs").selectAll("marker")
      .data(["suit", "licensing", "resolved", "self_loop", "suit_gray", "licensing_gray", "resolved_gray", "self_loop_gray"])
    .enter().append("marker")
      .attr("id", function(d) { return d; })
      .attr("viewBox", "0 -5 10 10")
      .style("fill", function(d) {
        console.log("~~~~~~~~~~~")
        console.log(d)
        if (d.includes("_gray"))
          return "silver";
        else
          return "black";
      })
      .attr("refX", function(d) {
        if (d.includes("self_loop")) {
          return 20;
        }
        else {
          return 20; 
        }
      })
      .attr("refY", function(d) {
        if (d == "self_loop") {
          return -3.5;
        }
        else
          return -1.5; 
      })
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", function(d) {
        if (d == "self_loop") {
          return 90;
        }
        else {
          //console.out("cowabunga")
          return "auto"; 
        }
      })
    .append("path")
      .attr("d", "M0,-5L10,0L0,5");

    var path = svg.append("g").selectAll("path")
      .data(force.links())
    .enter().append("path")
      //.attr("class", "link-group")
      .attr("id", function(d,i) { return "linkId_" + i})
      .attr("class", function(d) { return "link " + d.type; })
      .attr("marker-end", function(d) { return "url(#" + d.type + ")"; })
      .style("stroke", function(d) {
        if (d.source.reach == false)
          return "silver";
        else
          return "black";
      });

      

    var circle = svg.append("g").selectAll("circle")
      .data(force.nodes())
    .enter().append("circle")
      .attr("r", 10)
      .style("fill", function(d){ 
        if (d["real_id"] == 0)
          return "#7f7"
        else if (d["final"])
          return "#f77"
        else
          return "white";
      })
      .style("stroke", function(d) {
        if (d.reach == false)
          return "silver";
        else
          return "black";
      })
      //.call(force.drag);
      .call(node_drag);

    var text = svg.append("g").selectAll("text1")
      .data(force.nodes())
    .enter().append("text")
      .attr("x", 12)
      .attr("y", ".31em")
      .style("font", "normal 12px Arial")
      .style("fill", function(d) {
        if (d.reach == false)
          return "silver";
        else
          return "black";
      })
      .text(function(d) { 
        return d.name.toUpperCase(); 
      });
    
    if (nonverb) {
      /*
      var gaze_text = svg.append("g").selectAll("gaze_text")
        .data(force.nodes())
      .enter().append("text")
        .attr("x", 12)
        .attr("y", "1.2em")
        .style("font", "normal 12px Arial")
        .style("fill", function(d) {
          if (d.reach == false)
            return "silver";
          else
            return "black";
        })
        .text(function(d) { 
          return "gaze: " + d.gaze; 
        });
    */

      var gesture_text = svg.append("g").selectAll("gesture_text")
        .data(force.nodes())
      .enter().append("text")
        .attr("x", 12)
        .attr("y", "1.2em")
        .style("font", "normal 12px Arial")
        .style("fill", function(d) {
          if (d.reach == false)
            return "silver";
          else
            return "black";
        })
        .text(function(d) { 
          return "gesture: " + d.gesture; 
        });
    }

    /*
    var labeltext = svg.append("g").selectAll("text")
      .data(force.links())
    .enter().append("text")
      .attr("x", 12)
      .attr("y", ".31em")
      .text(function(d) { return d.label; });
    */

    
    var link = svg.selectAll(".link")
      .data(links)
      .enter()
      .append("g")
      .attr("class", "link-group")
      .append("path")
      .attr("class", function(d) { return d.label; })
      .style("stroke-width", function(d) { return Math.sqrt(d.stroke); });

    var linkText = svg.selectAll(".link-group")
      .append("text")
      .data(force.links())
      .text(function(d) { return d.label; })
      .attr("x", function(d) { return (d.source.x + (d.target.x - d.source.x) * 0.5); })
      .attr("y", function(d) { return (d.source.y + (d.target.y - d.source.y) * 0.5); })
      .attr("dy", ".25em")
      .attr("text-anchor", "middle");

    var labelText = svg.selectAll("g.linklabelholder").data(force.links());
    labelText.enter().append("g").attr("class", "linklabelholder")
      .append("text")
      .attr("class","linkLabel")
      .attr("dx",20)
      .attr("dy",0)
      .attr()
      .attr("text-anchor", "middle")
      .style("fill", function(d) {
        if (d.source.reach == false)
          return "silver";
        else
          return "black";
      })
      //.style("fill","red")
    //.append("textPath")
      //.attr("xlink:href",function(d,i) { return "#linkId_" + i;})
      .text(function(d) { return d.label;});

    // Use elliptical arc path segments to doubly-encode directionality.
    function tick() {
      //path.attr("d", linkArc);
      circle.attr("transform", transform);
      text.attr("transform", transform);  
      if (nonverb) {
        //gaze_text.attr("transform", transform)
        gesture_text.attr("transform", transform)
      }
      labelText.attr("transform", function(d) {

        if (d.source == d.target) {
          return "translate(" + (d.source.x + 40) + "," + (d.source.y - 40) + ")";
        }
        else if (d.is_alone=="false") {
          var dx = d.target.x - d.source.x,
          dy = d.target.y - d.source.y,
          dr = Math.sqrt(dx * dx + dy * dy);

          // We know the center of the arc will be some distance perpendicular from the
          // link segment's midpoint. The midpoint is computed as:
          var endX = (d.target.x + d.source.x) / 2;
          var endY = (d.target.y + d.source.y) / 2;

          // Notice that the paths are the arcs generated by a circle whose 
          // radius is the same as the distance between the nodes. This simplifies the 
          // trig as we can simply apply the 30-60-90 triangle rule to find the difference
          // between the radius and the distance to the segment midpoint from the circle 
          // center.
          var len = dr - ((dr/2) * Math.sqrt(3));
          
          // Remember that is we have a line's slope then the perpendicular slope is the 
          // negative inverse.
          endX = endX + (dy * len/dr);
          endY = endY + (-dx * len/dr);
            
          ///return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + endX + "," + endY;

          ////return "translate(" + (d.source.x + d.target.x) / 2 + "," 
          ////+ (d.source.y + d.target.y) / 2 + ")"; });
          return "translate(" + endX + "," + endY + ")";
        }
        else {
          console.log("HIHDOFISDPHFSD")
          //linkText
          //.attr("x", function(d) { return (d.source.x + (d.target.x - d.source.x) * 0.5); })
          //.attr("y", function(d) { return (d.source.y + (d.target.y - d.source.y) * 0.5); });
          return "translate(" + (d.source.x + (d.target.x - d.source.x) * 0.5) + "," + (d.source.y + (d.target.y - d.source.y) * 0.5) + ")";
       }

      });
      path.attr("d", linkArc);
      //labeltext.attr("transform", transform)
      //linkText
      //  .attr("x", function(d) { return (d.source.x + (d.target.x - d.source.x) * 0.5); })
      //  .attr("y", function(d) { return (d.source.y + (d.target.y - d.source.y) * 0.5); }); 
    }

    function linkArc(d) {
      var dx = d.target.x - d.source.x,
          dy = d.target.y - d.source.y,
          dr = Math.sqrt(dx * dx + dy * dy);

      if (d.source == d.target) {
        // Fiddle with this angle to get loop oriented.
        xRotation = -45;

        // Needs to be 1.
        largeArc = 1;

        // Change sweep to change orientation of loop. 
        //sweep = 0;

        // Make drx and dry different to get an ellipse
        // instead of a circle.
        drx = 30;
        dry = 20;

        // For whatever reason the arc collapses to a point if the beginning
        // and ending points of the arc are the same, so kludge it.
        x2 = d.target.x + 1;
        y2 = d.target.y + 1;

        sweep = 1;

        return "M" + d.source.x + "," + d.source.y + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
      }
      else if (d.is_alone=="false")
        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
      else
        return "M" + d.source.x + "," + d.source.y + "," + d.target.x + "," + d.target.y;
    }

    function transform(d) {
      d.x = Math.max(10, Math.min(width - 10, d.x));
      d.y = Math.max(10, Math.min(height - 10, d.y));
      return "translate(" + d.x + "," + d.y + ")";
    }

    function dragstart(d, i) {
      force.stop() // stops the force auto positioning before you start dragging
    }
    function dragmove(d, i) {
      d.px += d3.event.dx;
      d.py += d3.event.dy;
      d.x += d3.event.dx;
      d.y += d3.event.dy;
      d3.select(this).attr("transform", function(d,i){
        return "translate(" + [ d.x,d.y ] + ")"
      })
      for (i = 0; i < links.length; i++) {
        if (links[i].target == d || links[i].source == d) {
          path.attr("d", linkArc);

        }
      }
      //labelText.attr("transform", function(d) {
        // Get the length of the path
      //  var pathLen = d.getTotalLength();

        // How far along the path to we want the position?
      //  var pathDistance = pathLen * 0.5;

        // Get the X,Y position
      //  var midpoint = myarc.getPointAtLength(pathDistance)
      //  return "translate(" + (d.source.x + d.target.x) / 2 + "," 
      //  + (d.source.y + d.target.y) / 2 + ")";
      //});
    }

    function dragend(d, i) {
      d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
      force.resume();
    }
  });
});

</script>