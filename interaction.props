FAIRNESS TRUE
P>=1 [F "group_Wait_For_Next_People"];
P>=1 [(F "group_All_Topics") | ((F "group_Topic_1") | (F "group_Topic_2") | (F "group_Topic_3"))];
FAIRNESS FALSE

# there must exist paths to moving to the next exhibit
E [ F ("group_Move" | "group_QA_While_Move")]

# we can infinitely often access all topics or topic 1
E [ G F ("group_All_Topics" | "group_Topic_1")];

# we can infinitely often access move or QA move
E [ G F ("group_Move" | "group_QA_While_Move")];

P>=1 [(F "group_All_Topics") => !((F "group_Topic_1") | (F "group_Topic_2") | (F "group_Topic_3"))];
P>=1 [((F "group_Topic_1") | (F "group_Topic_2") | (F "group_Topic_3")) => !(F "group_All_Topics")];
P>=1 [G ( ( "group_All_Topics" | "group_Topic_1" | "group_Topic_2" | "group_Topic_3") => !(F "group_Greet_People"))];
P>=1 [G (("group_Wait_For_People" & "out_Ignore") => (X "group_Wait_For_People"))];

# where can all-topics go, and what will the input be?
P>=1 [G (("group_All_Topics" & "out_Ignore") => ((X "group_Initiate_Escort") | (X "group_Move") | (X "group_QA_While_Move")))];
P>=1 [G (("group_All_Topics" & "out_Ready") => (X "group_All_Topics") ) ];

# where can the indiv topics go, and what will the input be?
P>=1 [ G (("group_Topic_1" & "out_Ready") => (X "group_Topic_2")) ];
P>=1 [ G (("group_Topic_2" & "out_Ready") => (X "group_Topic_3")) ];
P>=1 [G (("group_Topic_3" & "out_Ready") => ( X ( "group_Initiate_Escort" | "group_Move" | "group_QA_While_Move")))];

# where can the escorting go?
P>=1 [G (("group_Initiate_Escort" & "out_Ready") => ( X ("group_Move" | "group_QA_While_Move")))];
A [G ((("group_Move" | "group_QA_While_Move") & "out_state") => !(X ("group_Move" | "group_QA_While_Move")))];
EOP
